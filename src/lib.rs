// Copyright 2021 Shin Yoshida
//
// "LGPL-3.0-or-later OR Apache-2.0 OR BSD-2-Clause"
//
// This is part of mouse-leveldb
//
//  mouse-leveldb is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  mouse-leveldb is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public License
//  along with mouse-leveldb.  If not, see <http://www.gnu.org/licenses/>.
//
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// Redistribution and use in source and binary forms, with or without modification, are permitted
// provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this list of
//    conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice, this
//    list of conditions and the following disclaimer in the documentation and/or other
//    materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//! `mouse-leveldb` is a wrapper of crate `leveldb-sys` for `mouse` .

#![deny(missing_docs)]

mod options;
mod write_options;

use core::ptr::{null_mut, NonNull};
use core::result::Result;
use leveldb_sys::*;
use once_cell::sync::Lazy;
use options::Options;
use std::ffi::CStr;
use std::fmt;
use std::os::raw::{c_char, c_void};
use write_options::WriteOptions;

static OPTIONS: Lazy<Options> = Lazy::new(|| Options::new());
static WRITE_OPTIONS: Lazy<WriteOptions> = Lazy::new(|| WriteOptions::new());

/// `Error` implements `std::error::Error` .
pub struct Error(NonNull<c_char>);

unsafe impl Send for Error {}
unsafe impl Sync for Error {}

impl Drop for Error {
    fn drop(&mut self) {
        unsafe { leveldb_free(self.0.as_ptr() as *mut c_void) };
    }
}

impl Error {
    /// Creates a new instance wrapping `ptr` .
    ///
    /// # Safety
    ///
    /// `ptr` must be generated by functions in crate `leveldb_sys` ; otherwise it may lead memory
    /// unsafety.
    #[inline]
    const unsafe fn new(ptr: NonNull<c_char>) -> Self {
        Self(ptr)
    }
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let msg = unsafe { CStr::from_ptr(self.0.as_ptr()).to_str().unwrap() };
        f.debug_tuple("Error").field(&msg).finish()
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let msg = unsafe { CStr::from_ptr(self.0.as_ptr()).to_str().unwrap() };
        msg.fmt(f)
    }
}

impl std::error::Error for Error {}

/// `Database` is a wrapper of `*mut leveldb_t` to make sure to close on the drop.
pub struct Database(Option<*mut leveldb_t>);

unsafe impl Send for Database {}
unsafe impl Sync for Database {}

impl Drop for Database {
    fn drop(&mut self) {
        self.close();
    }
}

impl Database {
    /// Creates a new instance with unopened state.
    ///
    /// # Examples
    ///
    /// ```
    /// use mouse_leveldb::Database;
    ///
    /// let _db = Database::new();
    /// ```
    pub const fn new() -> Self {
        Self(None)
    }

    /// Creates a database if not exists and opens.
    ///
    /// `path` is the path to the directory where database files are stored.
    ///
    /// # Panics
    ///
    /// Causes a panic if `self` has been already opened.
    ///
    /// # Examples
    ///
    /// ```
    /// use mouse_leveldb::Database;
    /// use std::ffi::CString;
    /// use tempfile;
    ///
    /// let tmp = tempfile::tempdir().unwrap();
    /// let path = CString::new(tmp.path().to_str().unwrap()).unwrap();
    ///
    /// let mut db = Database::new();
    /// db.open(&path).unwrap();
    /// ```
    pub fn open(&mut self, path: &CStr) -> Result<(), Error> {
        assert_eq!(None, self.0);

        unsafe {
            let mut error: *mut c_char = null_mut();
            let errptr: *mut *mut c_char = &mut error;

            let ptr = leveldb_open(OPTIONS.as_ptr(), path.as_ptr(), errptr);
            match NonNull::new(error) {
                Some(e) => {
                    assert_eq!(true, ptr.is_null());
                    Err(Error::new(e))
                }
                None => {
                    assert_eq!(false, ptr.is_null());
                    self.0 = Some(ptr);
                    Ok(())
                }
            }
        }
    }

    /// Returns a pointer to the wrapped address.
    ///
    /// Note that `leveldb_t` is `Sync` .
    fn as_ptr(&self) -> Option<*mut leveldb_t> {
        self.0
    }

    /// Closes the DB and makes `self` unopend state if opened; otherwise does nothing.
    pub fn close(&mut self) {
        if let Some(ptr) = self.0 {
            unsafe { leveldb_close(ptr) };
            self.0 = None;
        }
    }
}

/// `WriteBatch` is a wrapper of `*mut leveldb_writebatch_t` to make sure to destruct on the drop.
pub struct WriteBatch(Option<*mut leveldb_writebatch_t>);

impl Drop for WriteBatch {
    fn drop(&mut self) {
        self.destroy();
    }
}

impl WriteBatch {
    /// Creates a new instance.
    ///
    /// # Examples
    ///
    /// ```
    /// use mouse_leveldb::WriteBatch;
    ///
    /// let _batch = WriteBatch::new();
    /// ```
    pub const fn new() -> Self {
        Self(None)
    }

    /// Initializes `self` .
    ///
    /// # Panics
    ///
    /// Causes a panic if `self` has already been initialized.
    #[inline]
    fn init(&mut self) {
        assert_eq!(None, self.0);

        let ptr = unsafe { leveldb_writebatch_create() };
        assert_eq!(false, ptr.is_null());

        self.0 = Some(ptr);
    }

    /// Makes sure to destructs the wrapped pointer.
    ///
    /// # Examples
    ///
    /// ```
    /// use mouse_leveldb::WriteBatch;
    ///
    /// let mut batch = WriteBatch::new();
    /// batch.destroy();
    /// ```
    pub fn destroy(&mut self) {
        if let Some(ptr) = self.0 {
            unsafe { leveldb_writebatch_destroy(ptr) };
            self.0 = None;
        }
    }
}
